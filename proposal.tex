\section{The {\aser} Proposal}
\label{sec:proposal}

To overcome the problems discussed above, we consider two key changes in the plan model. 

%
% 
%
The first one is to extend the body of plans beyond the simple sequence of actions and goals, so as to include also the possibility to specify a reactive behaviour encapsulated in the plan.
%
Coherently with the {\asl} model, such a behaviour can be expressed in terms of e-plans.
%
Accordingly, a plan body becomes the \emph{scope} of both a sequence of actions -- referred as \emph{main sequence of actions} -- and a set of e-plans, specifying a reactive behaviour which is active at runtime only when the plan is in execution, and g-plans, specifying plans to achieve goals that are relevant only in the scope of this plan.
%
The e-plans set may include also reactions to failures occurring when executing actions of the main sequence or the body of e-plans.

%
%
%
The second one is enforcing e-plans -- as pieces of reactive behaviours -- must always be defined in the context of a g-plan -- that is we enforce the principle that an agent does (and reacts) always because of a goal to achieve or maintain.
%
This enforce the programmers to explicitly specify what's the goal to achieve even when defining a pure reactive behaviour. 
%
In so doing, at runtime every intention -- i.e., plan in execution -- is associated to a goal to achieve.

In the remainder of the section we first describe in detail the syntax and informal semantics of the new plan model, including simple examples, and then we discuss the key benefits. 

\subsection{Informal Syntax and Semantics}

At the top level, an {\aser} program is a collection of g-plans, whose syntax is shown in the following:
%
% CURRENT VERSION 0.2 (in the doc)
%
{\small
\begin{verbatim}
/*  g-plans */
+!g : c <: gc { 

  <- a; b; ?g1; !g1; !!g2. // main sequence, optional.

  /* e-plans */
  +e1 : c1 <- b1.	
  +e2 : c2 <- b2.
  +!k : true <: b(10) {
    <- a,b,c.
    +e3 : c3 <- b3. // possible old-style plans
  }	
  
  /* e-plans catching failures */
  -!g[error(ia_failed)] : ...
    <- ... catches from failures 

  /* further g-plans */
  +!g1 : c1 <: gc1 { ... }
}

\end{verbatim}}

Like in {\asl}, a g-plan is defined by rule with a head and a body.
%
In {\aser} the body is defined by two elements: 
%
a \emph{plan block}, including a main sequence and a set of plans, and a \emph{goal condition} \textsf{gc}---which is a belief formula analogous to the context. 
%
The main sequence of actions can be empty---this is the case of plans expressing a pure reactive behaviour.
%

%
Conceptually, the sub-plans (e-plans and g-plans) stored in the plan block are available in the plan library only when the g-plan is an execution.
%
Like in {\asl}, as soon as the g-plan is instantiated, the main sequence is executed.
%
If no goal condition is specified, the plan is considered completed as soon as the main sequence is completed.
%
Otherwise, the g-plan is considered completed only if/when the beliefs expressed in the goal condition hold. 
%

% GoalCondition is analogous to the context: however, if context can be considered to be as the pre-condition to execute the plan, the GoalCondition are like a post-condition, which corresponds to a declarative description of the goal to be achieved. 
%
%Alternatively, the execution of a plan can be forced to complete by using an internal action .done - this is useful everytime the goal condition cannot be effectively or naturally described as a boolean expression.
%
%If [GoalCondition] is not specified, by default the condition is that all actions of the main sequence have been executed and completed, in continuity with the AS model. This condition is explicitly represented by the new predefined predicate \texttt{.is\_done}.
%
% The body of the plan provides a lexical and runtime scope of the sub-plans, that is:  variables used in the g/c expression are visible also to subplans the lifetime/availability of the sub-plans is limited to the time in which the g-plan is in execution


While a g-plan is in execution, if the agent perceives an event triggering a sub-plan described in the plan block and the sub-plan is applicable according to its specified context, then the body of the plan is stacked on top of the stack of the current intention (associated to the g-plan).
%
If the agent was executing the main sequence, the effect is to \emph{interrupt} it so as to execute the body of the sub-plan.
%
In {\asl} this is the case when executing a sub-plan associated to a goal defined in the sequence, e.g.: \textsf{a1; a2; !g1; a3}, in a synchronous way.
%
In {\aser} this uniformly occurs also with any kind of events, not only goal events, that is:
%
the main sequence can be \emph{asynchronously} interrupted to react to events coming from the environment.
%
This behaviour is ruled by the (extended) reasoning cycle, which will be described in next section.

% Failures generated by either the main sequence or by sub-plans generate a -!g that could handled.

[TO BE COMPLETED]

\subsection{Examples}

Let's consider  the examples seen in {\ref{sec:motivation}},  to see how they be encoded in {\aser}. 
%
Robot cleaning example becomes:

\begin{small}
\begin{verbatim}
+!clean_env <: false {
  +location(waste,X):location(robot,X) & location(bin,Y)
    <- pick(waste); !location(robot,Y); drop(waste).
  ...
}
\end{verbatim}
\end{small}

\noindent That is: now we can give an explicit reason to the reactive behaviour by encapsulating the e-plan inside a g-plan, with an explicit goal.
%
Setting the goal condition to false means that  the plan execution is going to last for ever. It is a way to implement kind of maintenance goal.
%
As a further note, this is a particular case in that the plan body has no main sequence.
%

The Elab num example:

{\small
\begin{verbatim}
+!elab_nums(0).
+!elab_nums(N) <: stop || .main_done {
  <- !elab(N); !elab_nums(N-1).	
  +!elab(M) <- ...
}
\end{verbatim}}

%
\noindent {.main\_done} is a predefined meta belief, which holds when the main sequence has been executed. 

In the case that we want to do some actions when reacting to stop, then we can introduce a e-plan as follows:

{\small
\begin{verbatim}
+!elab_nums(N) <- {
  <- !elab(N);
      !elab_nums(N-1).
  +!elab(N') <- ...
  +stop 
    <- println("stopped"); .done.		
}
+!elab_nums(0).
\end{verbatim}}

\noindent  The approach allows to avoid towers of subgoal calls, that are used when a plan do some action and then should wait that some condition is achieved, in order to complete, eventually reacting to some events to adapt the course of actions. 
%
An example is the simple thermostat. 
%
Let's consider the goal to achieve some temperature +!temp(T):

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T & not warming
  <-  switchOnWarming; !temp(T).
+!temp(T) : temp(CT) & CT > T & not cooling
  <-  switchOnCooling; !temp(T).
+!temp(T) : temp(CT) & CT != T 
  <-  !temp(T).
+temp(T) : temp(T) <-  stop.
\end{verbatim}}

\noindent There is here a kind \emph{cognitive busy waiting} situation: after switching on the HVAC system (to cool or to warm), then the strategy needs to continuously check the condition to know when/if the goal has been achieved, before ending the plan.
%
This is problematic for 2 reasons: the size of the intention stack is growing indefinitely, and 
performance overhead. 

A solution with the extended plan model:

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T 
  <: temp(T) & not warming & not cooling {  
  <- switchOnWarming.
  +temp(T) <- stop. // There is bound	
}

+!temp(T) : temp(CT) & CT > T 
  <: temp(T) & not warming & not cooling {  
  <- switchOnCooling.	
  +temp(T) <- stop.		
}
+!temp(T) : temp(T).
\end{verbatim}}

Remarks:
\begin{itemize}
\item the T variable used inside the plan body (+temp(T) <-..) has been bound in +!temp(T)
\end{itemize}

\noindent  In Jason, the original AgentSpeak(L) solution could be avoided  by exploiting a .wait internal action that suspends a plan until some condition is achieved:

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T 
  <-  switchOnWarming;
      .wait(temp(T));
      stop.

+!temp(T) : temp(CT) & CT > T 
  <-  switchOnCooling;
      .wait(temp(T));
      stop.
\end{verbatim}}

\noindent However this solution is no more effective (alone) as soon as something could happen while waiting that need to change the course of actions.  
%
For instance, suppose that while warming the temperature value surpasses the target value T, such that we would need to start cooling. In this case, the .wait solution must be strongly reworked and becomes complicated.
%
The complete solution using the extended plan model:

{\small
\begin{verbatim}
+!temp(T) <: temp(T) & not warming & not cooling {
  +temp(T) <- stop.		
  +temp(T1) : T1 > T <- switchOnCooling.	
  +temp(T1) : T1 < T <- switchOnWarming.		
}\end{verbatim}}


\noindent Maintenance goal: to achieve and keep the temperature at the target temperature T, with the possibility of dynamically updating/changing T.

{\small
\begin{verbatim}
+!target_temp(T) <: false {
  <- +target_temp(T).	
 
  +temp(T) : target_temp (T) <- stop.		
  +temp(T1) : target_temp(TT) & T1 > TT <- switchOnCooling.	  
  +temp(T1) : target_temp(TT) & T1 < TT <- switchOnWarming.
 
  +target_temp(TT) : temp(TT)  <- stop.	
  +target_temp(TT) : 
    temp(T) & T < TT & not warming <- switchOnWarming.
  +target_temp(TT) : 
    temp(T) & T > TT & not cooling <- switchOnCooling.
}
\end{verbatim}}

% \subsubsection{Failure Management}

Failures generated by the execution of actions of sub-plans failures can be handled and managed:

\begin{itemize}
\item by sub-plans listed in the body of the plan
\item by plans at the same level of +!g, if the event is not managed inside the body
\end{itemize}

\noindent In the latter case, the event representing the failure could be exactly -!g as in Jason, i.e. the event which is generated when the goal is removed.
%
This strategy cannot be adopted in the former case, since we want to react to a failure but the corresponding goal and intention have not been removed yet, so no -!g event is generated. For this reason, we need to introduce a new event:  \texttt{+/err\_term}  [TEMPORARY SYNTAX]  representing the failure of an action belonging to the main sequence or to the body of subplans.  

{\small
\begin{verbatim}
+!g : c <: GoalCondition {
  <- a; b; ? ; c. 
  ...
  +/err_term : cn <- bn
}
\end{verbatim}}

\noindent In the cycle, the \texttt{+/err\_term} is treated as the other events: if an applicable plan is found, it is selected and executed (in the same intention). 
%
Otherwise, the behaviour is like it is in pure AgentSpeak(L) - the whole intention is removed and a \texttt{-!g} event is generated.

\subsection{Discussion}

[TO BE COMPLETED]

In this section we go back on the key issues, showing how the approach is effective in overcoming them.
%
Besides, we explicit discuss further goodies that the model brings in agent programming.

\subsubsection{Full encapsulation}

\subsubsection{Explicit vs. Implicit Goals}

\subsubsection{Failure Handling}

\subsubsection{Coarse-grained Intentions}

In AgentSpeak, each e-plan in execution has its own intention/stack, which runs concurrently to the other intentions. Conceptually, this follows the idea that that the management of environment events are not part of an existing plan to achieve some goal.
%
In the new model instead, an e-plan inside a g-plan is meant to specify a behaviour useful for achieving the goal of the g-plan, so part of the same intention.
%
For this reason, the an e-plan (subplan) inside a g-plan in execution is triggered, no new intentions are generated and the body of the sub-plan is placed on the top of the stack of the same intention. 
%
The new model leads than to have more coarse-grained intentions, reducing overall the number of intentions. This has an impact on the reasoning cycle, for instance on the step selecting the intention to carry on.

\subsubsection{Intention implicit Interruption}

The effect is to implicitly interrupt and suspend the main sequence (body) of the g-plan - if available and if not already completed.
%
Conceptually, this is the asynchronous version of the suspension that occurs when a subgoal is specified (!g) in the body of a plan. This causes exactly the suspension of the body and the pushing of the body of the new plan on the top of the stack of the intention.

\subsubsection{Compatibility with {\asl}}

