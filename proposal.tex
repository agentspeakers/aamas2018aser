\section{The {\aser} Proposal}
\label{sec:proposal}

The basic idea is to extend the model of the body in plans (g-plans in particular) beyond the simple sequence of actions, so as to include also the possibility to specify a reactive behaviour encapsulated in the plan, that is: the plan body is the scope of the the rules or code specifying that behaviour and, at runtime, that behaviour is active only when the plan is in execution.

In coherence with the AgentSpeak(L) model, we express that reactive behaviour in terms of subplans, i.e. e-plans.  
%
For uniformity, instead of limiting the subplans to be only e-plans, we allow also g-plans, getting the further benefit of improving the encapsulation/modularity of plans related to goals.

\subsection{Informal Syntax and Semantics}

%
% CURRENT VERSION 0.2 (in the doc)
%
{\small
\begin{verbatim}
/*  g-plans */
+!g : c <: goal_condition { 
  <- a; b; ?; !k; c. 	// main body, optional.

  /* e-plans */
  +e1 : c1 <- b1.	
  +e2 : c2 <- b2.
  +!k : true <: b(10) {
    <- a,b,c.
    +e3 : c3 <- b3. // possible old-style plans
  }	
  
  /* e-plans catching failures */
  -!g[error(ia_failed)] : ...
    <- ... catches from failures 
}
\end{verbatim}}

Informal semantics:
\begin{itemize}

\item The sub-plans are part of the strategy which can be applied to achieve the g-plan.
%
The main sequence of actions (body plan) can be empty.
%
If an event triggering a sub-plan is triggered while the g-plan is executing, i.e. the main sequence is in execution, and the sub-plan is applicable according to the context, then the body of the subplan is stacked on top of the stack of the current (g-plan related) intention.
%
The effect is like an asynchronous interruption of the main sequence, to execute the body of the sub-plan.

\item The execution of the extended plan is considered completed if/when the condition described by the GoalCondition expression are met. 
%
GoalCondition is analogous to the context: however, if context can be considered to be as the pre-condition to execute the plan, the GoalCondition are like a post-condition, which corresponds to a declarative description of the goal to be achieved. 
%
Alternatively, the execution of a plan can be forced to complete by using an internal action .done - this is useful everytime the goal condition cannot be effectively or naturally described as a boolean expression.
%
If [GoalCondition] is not specified, by default the condition is that all actions of the main sequence have been executed and completed, in continuity with the AS model. This condition is explicitly represented by the new predefined predicate \texttt{.is\_done}.

\item The body of the plan provides a lexical and runtime scope of the sub-plans, that is: 
variables used in the g/c expression are visible also to subplans
 the lifetime/availability of the sub-plans is limited to the time in which the g-plan is in execution

\item Failures generated by either the main sequence or by sub-plans generate a -!g that could handled.

\end{itemize}

\subsubsection{Examples}

Let's consider the problems discussed before. 
%
Bomb example:

{\small
\begin{verbatim}
+!remove_bombs <: false {
  +bomb(Terminal, Gate, BombType) : skill(BombType)
    <- !go(Terminal, Gate); disarm(BombType).
  @p2
  +bomb(Terminal, Gate, BombType) : ?skill(BombType)
    <- !moveSafeArea(Terminal, Gate, BombType).
  @p3
  +bomb(Terminal, Gate, BombType) : 
    not skill(BombType) & not ?skill(BombType)
    <- .broadcast(tell, alter).
}
\end{verbatim}}

\noindent Setting the goal condition to false means that  the plan execution is going to last for ever. It is a way to implement kind of maintenance goal.
%
As a further note, this is a particular case in that the plan body has no main sequence.
%


The Elab num example:

{\small
\begin{verbatim}
+!elab_nums(N) <: stop || .is_done {
  <- !elab(N); !elab_nums(N-1).	
  +!elab(M) <- ...
}
+!elab_nums(0).
\end{verbatim}}

\noindent  In the case that we want to do some actions when reacting to stop, then we can introduce a e-plan as follows:

{\small
\begin{verbatim}
+!elab_nums(N) <- {
  <- !elab(N);
      !elab_nums(N-1).
  +!elab(N') <- ...
  +stop 
    <- println("stopped"); .done.		
}
+!elab_nums(0).
\end{verbatim}}

\noindent  The approach allows to avoid towers of subgoal calls, that are used when a plan do some action and then should wait that some condition is achieved, in order to complete, eventually reacting to some events to adapt the course of actions. 
%
An example is the simple thermostat. 
%
Let's consider the goal to achieve some temperature +!temp(T):

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T & not warming
  <-  switchOnWarming; !temp(T).
+!temp(T) : temp(CT) & CT > T & not cooling
  <-  switchOnCooling; !temp(T).
+!temp(T) : temp(CT) & CT != T 
  <-  !temp(T).
+temp(T) : temp(T) <-  stop.
\end{verbatim}}

\noindent There is here a kind \emph{cognitive busy waiting} situation: after switching on the HVAC system (to cool or to warm), then the strategy needs to continuously check the condition to know when/if the goal has been achieved, before ending the plan.
%
This is problematic for 2 reasons: the size of the intention stack is growing indefinitely, and 
performance overhead. 

A solution with the extended plan model:

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T 
  <: temp(T) & not warming & not cooling {  
  <- switchOnWarming.
  +temp(T) <- stop. // There is bound	
}

+!temp(T) : temp(CT) & CT > T 
  <: temp(T) & not warming & not cooling {  
  <- switchOnCooling.	
  +temp(T) <- stop.		
}
+!temp(T) : temp(T).
\end{verbatim}}

Remarks:
\begin{itemize}
\item the T variable used inside the plan body (+temp(T) <-..) has been bound in +!temp(T)
\end{itemize}

\noindent  In Jason, the original AgentSpeak(L) solution could be avoided  by exploiting a .wait internal action that suspends a plan until some condition is achieved:

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T 
  <-  switchOnWarming;
      .wait(temp(T));
      stop.

+!temp(T) : temp(CT) & CT > T 
  <-  switchOnCooling;
      .wait(temp(T));
      stop.
\end{verbatim}}

\noindent However this solution is no more effective (alone) as soon as something could happen while waiting that need to change the course of actions.  
%
For instance, suppose that while warming the temperature value surpasses the target value T, such that we would need to start cooling. In this case, the .wait solution must be strongly reworked and becomes complicated.
%
The complete solution using the extended plan model:

{\small
\begin{verbatim}
+!temp(T) <: temp(T) & not warming & not cooling {
  +temp(T) <- stop.		
  +temp(T1) : T1 > T <- switchOnCooling.	
  +temp(T1) : T1 < T <- switchOnWarming.		
}\end{verbatim}}


\noindent Maintenance goal: to achieve and keep the temperature at the target temperature T, with the possibility of dynamically updating/changing T.

{\small
\begin{verbatim}
+!target_temp(T) <: false {
  <- +target_temp(T).	
 
  +temp(T) : target_temp (T) <- stop.		
  +temp(T1) : target_temp(TT) & T1 > TT <- switchOnCooling.	  
  +temp(T1) : target_temp(TT) & T1 < TT <- switchOnWarming.
 
  +target_temp(TT) : temp(TT)  <- stop.	
  +target_temp(TT) : 
    temp(T) & T < TT & not warming <- switchOnWarming.
  +target_temp(TT) : 
    temp(T) & T > TT & not cooling <- switchOnCooling.
}
\end{verbatim}}

\subsection{Failure Management}

Failures generated by the execution of actions of sub-plans failures can be handled and managed:

\begin{itemize}
\item by sub-plans listed in the body of the plan
\item by plans at the same level of +!g, if the event is not managed inside the body
\end{itemize}

\noindent In the latter case, the event representing the failure could be exactly -!g as in Jason, i.e. the event which is generated when the goal is removed.
%
This strategy cannot be adopted in the former case, since we want to react to a failure but the corresponding goal and intention have not been removed yet, so no -!g event is generated. For this reason, we need to introduce a new event:  \texttt{+/err\_term}  [TEMPORARY SYNTAX]  representing the failure of an action belonging to the main sequence or to the body of subplans.  

{\small
\begin{verbatim}
+!g : c <: GoalCondition {
  <- a; b; ? ; c. 
  ...
  +/err_term : cn <- bn
}
\end{verbatim}}

\noindent In the cycle, the \texttt{+/err\_term} is treated as the other events: if an applicable plan is found, it is selected and executed (in the same intention). 
%
Otherwise, the behaviour is like it is in pure AgentSpeak(L) - the whole intention is removed and a \texttt{-!g} event is generated.

\subsection{Remarks}

\subsubsection{Coarse-grained Intentions}

In AgentSpeak, each e-plan in execution has its own intention/stack, which runs concurrently to the other intentions. Conceptually, this follows the idea that that the management of environment events are not part of an existing plan to achieve some goal.
%
In the new model instead, an e-plan inside a g-plan is meant to specify a behaviour useful for achieving the goal of the g-plan, so part of the same intention.
%
For this reason, the an e-plan (subplan) inside a g-plan in execution is triggered, no new intentions are generated and the body of the sub-plan is placed on the top of the stack of the same intention. 
%
The new model leads than to have more coarse-grained intentions, reducing overall the number of intentions. This has an impact on the reasoning cycle, for instance on the step selecting the intention to carry on.

\subsubsection{Intention implicit Interruption}

The effect is to implicitly interrupt and suspend the main sequence (body) of the g-plan - if available and if not already completed.
%
Conceptually, this is the asynchronous version of the suspension that occurs when a subgoal is specified (!g) in the body of a plan. This causes exactly the suspension of the body and the pushing of the body of the new plan on the top of the stack of the intention.


