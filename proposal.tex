\section{The {\aser} Proposal}
\label{sec:proposal}

To overcome the problems discussed above, we consider two key changes in the plan model. 

%
% 
%
The first one is to extend the plans beyond the simple sequence of actions and goals, so as to include also the possibility to specify a reactive behaviour encapsulated in the plan.
%
Coherently with the {\asl} model, such a behaviour can be expressed in terms of e-plans.
%
% JH: I changed a bit the terminology
Accordingly, a plan becomes the \emph{scope} of ($i$) a sequence of actions (referred as \emph{body actions}), ($ii$) a set of \emph{e-plans}, specifying a reactive behaviour which is active at runtime only when the plan is in execution, and ($iii$) a set of \emph{g-plans}, specifying plans to achieve subgoals that are relevant only in the scope of this plan. The e-plans and g-plans are referred as \emph{sub-plans}.
%
The sub-plans may include also reactions to failures occurring when executing the plan.

%
%
%
The second one is enforcing that e-plans -- as pieces of reactive behaviours -- must always be defined in the context of a g-plan. We are thus  enforcing the principle that an agent does (and reacts) always because of a goal to achieve or maintain.
%
This ensures that programmers explicitly specify what is the goal to achieve even when defining a pure reactive behaviour. 
%
In so doing, at runtime every intention \footnote{As in \asl, an intention is the result of the deliberation to commit to some desire. Briefly, if the agent has an applicable plan for a goal event (i.e.\ a desire), it commits to it by creating an intention based on that plan and starts executing that plan.} has an associated goal being pursued.

In the remainder of the section we first describe in detail the syntax and informal semantics of the new plan model, including simple examples, and then we discuss the key benefits. 

\subsection{Informal Syntax and Semantics}

At the top level, an {\aser} program is a collection of g-plans, whose syntax is exemplified in the following:
%
% CURRENT VERSION 0.2 (in the doc)
%
{\small
\begin{verbatim}
/*  g-plans to achieve goal g in context c */
+!g : c <: gc { 

  <- a; b; ?g1; !g1; !!g2. // body (optional).

  /* e-plans */
  +e1 : c1 <- b1.	
  +e2 : c2 <- b2.
  +!k : true <: b(10) {
    <- a,b,c.
    +e3 : c3 <- b3. // possible old-style plans
  }	
  
  /* e-plans catching failures */
  -!g[error(ia_failed)] : ...
    <- ... catches from failures 

  /* further g-plans */
  +!g1 : c1 <: gc1 { ... }
}
\end{verbatim}}

Like in {\asl}, a g-plan is defined with a head and a body.
%
% JH: avoid to use the term intention here... goal oriented programming. explain intention in the semantics
Besides the triggering event and the context, the head has a third new element: a \emph{goal condition}, optionally written after \texttt{<:}, with the same syntax as the context. While the context is a pre-condition to select a plan as applicable for an event, the goal condition is a post-condition that defines when the goal can be considered as achieved. Any goal created based on this g-plan is considered achieved if and only if this condition holds. If no goal condition is specified, the goal is considered achieved as soon as the body execution completes, as usual in \asl. However, if a goal condition is defined, to finish the body execution is not sufficient to achieve the goal. Notice that if the goal condition becomes true while the body actions are being executed, the execution stopped.

In {\aser} the body is enclosed by \texttt{\{} and \texttt{\}} and is composed of the body actions (after \texttt{<-}) and sub-plans. 
%
Like in {\asl}, as soon as a g-plan is instantiated, the body actions start to execute. The body actions can be empty -- this is the case of g-plans expressing a pure reactive behaviour.
%
The sub-plans of the g-plan are considered as relevant only for events produced by the g-plan execution. Since, they are in the scope of g-plan. 

% GoalCondition is analogous to the context: however, if context can be considered to be as the pre-condition to execute the plan, the GoalCondition are like a post-condition, which corresponds to a declarative description of the goal to be achieved. 
%
%Alternatively, the execution of a plan can be forced to complete by using an internal action .done - this is useful everytime the goal condition cannot be effectively or naturally described as a boolean expression.
%
%If [GoalCondition] is not specified, by default the condition is that all actions of the main sequence have been executed and completed, in continuity with the AS model. This condition is explicitly represented by the new predefined predicate \texttt{.is\_done}.
%
% The body of the plan provides a lexical and runtime scope of the sub-plans, that is:  variables used in the g/c expression are visible also to subplans the lifetime/availability of the sub-plans is limited to the time in which the g-plan is in execution


While a g-plan is executing, it can be \emph{interrupted} by events relevant for its e-plans. When the agent perceives an event and an e-plan from g-plan is applicable according to its specified context, then the execution of the g-plan body is suspended until the body of the e-plan finish its execution.
%
In {\asl}, other plans do also interrupts the execution of an plan in the case of sub-goals. For example, in the body \textsf{a1; a2; !g1; a3}, \textsf{g1} is a sub-goal and thus the action \textsf{a3} is executed after the body of \textsf{g1} has finished. The plan body execution in interrupted synchronously.
%
In {\aser} this uniformly occurs also with any kind of events, not only sub-goal events, that is: the body actions can be interrupted to react to events coming from the environment. However, in this case the interruption is \emph{asynchronous} -- the point where the body actions is interrupted is unknown.
%
This behaviour is ruled by the (extended) reasoning cycle, which will be described in next section.

% Failures generated by either the main sequence or by sub-plans generate a -!g that could handled.

[TO BE COMPLETED]

\subsection{Examples}

Considering the examples seen in Section~\ref{sec:motivation}, here we rewrite them in {\aser}. 
%
The robot cleaning example becomes:

\begin{small}
\begin{verbatim}
+!clean_env <: false {
   +location(waste,X) : location(robot,X) & location(bin,Y)
      <- pick(waste); !location(robot,Y); drop(waste).
}
\end{verbatim}
\end{small}

\noindent We can give an explicit reason for the reactive behaviour by encapsulating the e-plan inside a g-plan, with an explicit goal \texttt{clean\_env}.
%
Setting the goal condition to \texttt{false} means that  the plan execution is going to last for ever. It is a way to implement a kind of maintenance goal.
%
This is also a particular case where the body has no actions.
%

The \texttt{elab\_nums} example becomes:

{\small
\begin{verbatim}
+!elab_nums(0).
+!elab_nums(N) <: stop | .body_done {
   <- !elab(N); !elab_nums(N-1).	
   +!elab(M) <- ...
}
\end{verbatim}}

\noindent {. body\_done} is a predefined meta belief, which holds when the body actions have been executed. The goal \texttt{elab\_nums} is achieved either by the perception of \texttt{stop} or by the execution of its body actions.
%
In the case that we want to do some actions to react to \texttt{stop}, we can introduce an e-plan as follows:

{\small
\begin{verbatim}
+!elab_nums(0).
+!elab_nums(N) {
   <- !elab(N); !elab_nums(N-1).
   +!elab(N) <- ...
   +stop <- println("stopped"); .done.
}
\end{verbatim}}

\bigskip 
The proposed approach allows us to avoid towers of subgoal calls, that are used when a plan do some action and then should wait that some condition is achieved, in order to complete, eventually reacting to some events to adapt the course of actions. 
%
An example is the simple thermostat. 
%
Let's consider the goal to achieve some temperature +!temp(T):

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T & not warming
  <-  switchOnWarming; !temp(T).
+!temp(T) : temp(CT) & CT > T & not cooling
  <-  switchOnCooling; !temp(T).
+!temp(T) : temp(CT) & CT != T 
  <-  !temp(T).
+temp(T) : temp(T) <-  stop.
\end{verbatim}}

\noindent There is here a kind of \emph{cognitive busy waiting} situation: after switching on the HVAC system (to cool or to warm), then the strategy needs to continuously check the condition to know when/if the goal has been achieved, before ending the plan.
%
This is problematic for 2 reasons: the size of the intention stack is growing indefinitely and 
performance overhead. 
% JH: not sure we should go for performance arguments as above. the need to check all conditions every cycle is equivalent to the cost of the above cognitive busy waiting
%
The \aser version avoids that:

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T 
  <: temp(T) & not warming & not cooling {  
  <- switchOnWarming.
  +temp(T) <- stop. // There is bound
}

+!temp(T) : temp(CT) & CT > T 
  <: temp(T) & not warming & not cooling {  
  <- switchOnCooling.	
  +temp(T) <- stop.		
}
+!temp(T) : temp(T).
\end{verbatim}}

% JH: I am not sure to present this example, seems more complex than original code
% JH: it is not equivalent to ASL version: if the first plan is triggered, how could the second be triggered latter?

Remarks:
\begin{itemize}
\item the T variable used inside the plan body (+temp(T) <-..) has been bound in +!temp(T)
\end{itemize}

\noindent  In Jason, the original AgentSpeak(L) solution could be avoided  by exploiting a .wait internal action that suspends a plan until some condition is achieved:

{\small
\begin{verbatim}
+!temp(T) : temp(CT) & CT < T 
  <-  switchOnWarming;
      .wait(temp(T));
      stop.

+!temp(T) : temp(CT) & CT > T 
  <-  switchOnCooling;
      .wait(temp(T));
      stop.
\end{verbatim}}

\noindent However this solution is no more effective (alone) as soon as something could happen while waiting that need to change the course of actions.  
%
For instance, suppose that while warming the temperature value surpasses the target value T, such that we would need to start cooling. In this case, the .wait solution must be strongly reworked and becomes complicated.
%
The complete solution using the extended plan model:

{\small
\begin{verbatim}
+!temp(T) <: temp(T) & not warming & not cooling {
  +temp(T) <- stop.		
  +temp(T1) : T1 > T <- switchOnCooling.
  +temp(T1) : T1 < T <- switchOnWarming.
}
\end{verbatim}
}

% JH: shouldn't we present only the above solution? clear and simpler 
% is the test not warming/ not cooling necessary on the GC

\noindent Maintenance goal: to achieve and keep the temperature at the target temperature T, with the possibility of dynamically updating/changing T.

{\small
\begin{verbatim}
+!target_temp(T) <: false {
  <- +target_temp(T).	
 
  +temp(T) : target_temp (T) <- stop.		
  +temp(T1) : target_temp(TT) & T1 > TT <- switchOnCooling.	  
  +temp(T1) : target_temp(TT) & T1 < TT <- switchOnWarming.
 
  +target_temp(TT) : temp(TT)  <- stop.	
  +target_temp(TT) : 
    temp(T) & T < TT & not warming <- switchOnWarming.
  +target_temp(TT) : 
    temp(T) & T > TT & not cooling <- switchOnCooling.
}
\end{verbatim}}

% \subsubsection{Failure Management}

Failures generated by the execution of actions of sub-plans failures can be handled and managed:

\begin{itemize}
\item by sub-plans listed in the body of the plan
\item by plans at the same level of +!g, if the event is not managed inside the body
\end{itemize}

\noindent In the latter case, the event representing the failure could be exactly -!g as in Jason, i.e. the event which is generated when the goal is removed.
%
This strategy cannot be adopted in the former case, since we want to react to a failure but the corresponding goal and intention have not been removed yet, so no -!g event is generated. For this reason, we need to introduce a new event:  \texttt{+/err\_term}  [TEMPORARY SYNTAX]  representing the failure of an action belonging to the main sequence or to the body of subplans.  

{\small
\begin{verbatim}
+!g : c <: GoalCondition {
  <- a; b; ? ; c. 
  ...
  +/err_term : cn <- bn
}
\end{verbatim}}

\noindent In the cycle, the \texttt{+/err\_term} is treated as the other events: if an applicable plan is found, it is selected and executed (in the same intention). 
%
Otherwise, the behaviour is like it is in pure AgentSpeak(L) - the whole intention is removed and a \texttt{-!g} event is generated.

[add example of Single Mind Commitment]
[add example of disobedient agent]

\subsection{Discussion}

[TO BE COMPLETED]

In this section we go back on the key issues, showing how the approach is effective in overcoming them.
%
Besides, we explicit discuss further goodies that the model brings in agent programming.

\subsubsection{Full encapsulation}

\subsubsection{Explicit vs. Implicit Goals}

\subsubsection{Failure Handling}

\subsubsection{Coarse-grained Intentions}

In AgentSpeak, each e-plan in execution has its own intention/stack, which runs concurrently to the other intentions. Conceptually, this follows the idea that that the management of environment events are not part of an existing plan to achieve some goal.
%
In the new model instead, an e-plan inside a g-plan is meant to specify a behaviour useful for achieving the goal of the g-plan, so part of the same intention.
%
For this reason, the an e-plan (subplan) inside a g-plan in execution is triggered, no new intentions are generated and the body of the sub-plan is placed on the top of the stack of the same intention. 
%
The new model leads than to have more coarse-grained intentions, reducing overall the number of intentions. This has an impact on the reasoning cycle, for instance on the step selecting the intention to carry on.

\subsubsection{Intention implicit Interruption}

The effect is to implicitly interrupt and suspend the main sequence (body) of the g-plan - if available and if not already completed.
%
Conceptually, this is the asynchronous version of the suspension that occurs when a subgoal is specified (!g) in the body of a plan. This causes exactly the suspension of the body and the pushing of the body of the new plan on the top of the stack of the intention.

\subsubsection{Compatibility with {\asl}}

